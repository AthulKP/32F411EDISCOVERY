/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>
#include "spi_hal.h"
#include "gpio_hal.h"
#include "i3g4250d_hal.h"
#include "timer_hal.h"

uint8_t read_single_reg(volatile SPIx *, volatile GPIOx *, uint8_t);
void write_single_reg(volatile SPIx *, volatile GPIOx *, uint8_t, uint8_t);
void read_multiple_reg(volatile SPIx *, volatile GPIOx *, uint8_t, uint8_t, uint8_t *);
void delay_ms(volatile TIMx *, uint32_t);
void output_array_data(uint8_t *);


int main(void)
{

	volatile uint32_t *p_RCC_AHB1ENR = (uint32_t *)0x40023830;
	volatile uint32_t *p_RCC_APB2ENR = (uint32_t *)0x40023844;
	volatile uint32_t *p_RCC_APB1ENR = (uint32_t *)0x40023840;

	volatile TIMx *p_TIMER4 = (TIMx *)TIM4_Base_Address;

	volatile GPIOx *p_GPIOA = (GPIOx *)GPIOA_Base_Address;
	volatile GPIOx *p_GPIOE = (GPIOx *)GPIOE_Base_Address;

	volatile SPIx *p_SPI1 = (SPIx *)SPI1_Base_Address;

	// Clock enable
	*p_RCC_AHB1ENR |= (GPIOA_CLK_EN | GPIOE_CLK_EN);
	*p_RCC_APB2ENR |= SPI1_CLK_EN;

	// Timer 4 configuration with 1ms counting
	*p_RCC_APB1ENR |= RCC_TIMER4_EN;
	p_TIMER4->PSC   = PRESCALE_16000;
	p_TIMER4->ARR   = ARR_MAX;
	p_TIMER4->CR1  |= ENABLE_TIMER;

	// GPIO configuration
	p_GPIOA->MODER |= ((MODE_AF2 << SPI_SCK * BIT_RES_2) | (MODE_AF2 << SPI_MISO * BIT_RES_2) | (MODE_AF2 << SPI_MOSI * BIT_RES_2));
	p_GPIOE->MODER |= (MODE_OUTPUT << SPI_CS * BIT_RES_2);

	p_GPIOA->OSPEEDR |= ((HIGH_SPEED << SPI_SCK * BIT_RES_2) | (HIGH_SPEED << SPI_MISO * BIT_RES_2) | (HIGH_SPEED << SPI_MOSI * BIT_RES_2));
	p_GPIOE->OSPEEDR |= (HIGH_SPEED << SPI_CS * BIT_RES_2);

	p_GPIOA->PUPDR |= ((PULL_UP << SPI_SCK * BIT_RES_2) | (NO_PULL << SPI_MISO * BIT_RES_2) | (NO_PULL << SPI_MOSI * BIT_RES_2));
	p_GPIOE->PUPDR |= (PULL_UP << SPI_CS * BIT_RES_2);
	p_GPIOE->ODR |= (1 << SPI_CS);

	p_GPIOA->AFRL = ((AF5_SPI1 << SPI_SCK * BIT_RES_4) | (AF5_SPI1 << SPI_MISO * BIT_RES_4) | (AF5_SPI1 << SPI_MOSI * BIT_RES_4));

	// SPI configuration
	p_SPI1->CR1 = (uint16_t)(BIDIMODE_DIS | DFF_8BIT | SSM_EN | SSI_EN | LSB_FIRST | CLK_BY_4 | MSTR_EN | SPI_MODE_3);

	while (p_SPI1->SR & SPI_BUSY_FLAG); // wait until the SPI is not busy

	p_SPI1->CR1 |= SPI_EN;

	printf("Finding device...\n");
	while (WHO_AM_I != read_single_reg(p_SPI1, p_GPIOE, WHO_AM_I_REG));
	printf("Device active\n");

	uint8_t sensor_data[OUTPUT_REG_COUNT-1];

	printf("Configuring the device...\n");
	write_single_reg(p_SPI1, p_GPIOE, CTRL_REG1, 0xFF);
	printf("Configured\n");

	/* Loop forever */
	while (1)
	{
		if (read_single_reg(p_SPI1, p_GPIOE, STATUS_REG) & XYZ_DATA_AVAILABLE)
		{
			read_multiple_reg(p_SPI1, p_GPIOE, OUT_X_L_REG, OUTPUT_REG_COUNT, sensor_data);
			output_array_data(sensor_data);
		}
		delay_ms(p_TIMER4, 1);
	}
}

uint8_t read_single_reg(volatile SPIx *spi, volatile GPIOx *cs_gpio,uint8_t reg)
{
	cs_gpio->ODR &= ~(1 << SPI_CS); 		// CS LOW

	spi->DR = READ_MODE | SINGLE_REG | reg; // Request register address
	while (!(spi->SR & TXE));				// Wait for TXE (Transmit buffer empty)
	spi->DR = 0x00;						 	// Send dummy byte to make the clock continue
	while (!(spi->SR & RXNE));		   		// Wait for RXNE (Receive buffer full)
	(void)spi->DR; 							// Clear the buffer and reset RXNE flag
	while (!(spi->SR & RXNE)); 				// Wait for RXNE (Receive buffer full)

	cs_gpio->ODR |= (1 << SPI_CS); 			// CS HIGH

	return spi->DR;
}

void read_multiple_reg(volatile SPIx *spi, volatile GPIOx *cs_gpio, uint8_t start_reg, uint8_t reg_count, uint8_t *data_array)
{
	cs_gpio->ODR &= ~(1 << SPI_CS); 					// CS LOW

	spi->DR = READ_MODE | MULTIPLE_REG | start_reg; 	// Request register address
	while (!(spi->SR & TXE));							// Wait for TXE (Transmit buffer empty)
	spi->DR = 0x00; 									// Send dummy byte to make the clock continue
	while (!(spi->SR & RXNE));		   					// Wait for RXNE (Receive buffer full)
	(void)spi->DR; 										// Clear the buffer and reset RXNE flag
	for (int i = 0; i < reg_count; i++)
	{
		while (!(spi->SR & RXNE)); 						// Wait for RXNE (Receive buffer full)
		data_array[i] = spi->DR;
		if (i < reg_count - 1)
			spi->DR = 0x00;
	}

	cs_gpio->ODR |= (1 << SPI_CS);						// CS HIGH
}

void write_single_reg(volatile SPIx *spi, volatile GPIOx *cs_gpio, uint8_t reg,uint8_t data)
{
	cs_gpio->ODR &= ~(1 << SPI_CS); 	// CS LOW

	spi->DR = reg; 						// Request register address
	while (!(spi->SR & TXE));			// Wait for TXE (Transmit buffer empty)
	spi->DR = data;					    // Send dummy byte to make the clock continue
	while (!(spi->SR & RXNE));		    // Wait for RXNE (Receive buffer full)
	(void)spi->DR; 						// Clear the buffer and reset RXNE flag
	while (!(spi->SR & RXNE)); 			// Wait for RXNE (Receive buffer full)

	cs_gpio->ODR |= (1 << SPI_CS); 		// CS HIGH
}

void delay_ms(volatile TIMx *timer, uint32_t delay)
{
	timer->CNT = 0;
	while (timer->CNT <= delay);
}

void output_array_data(uint8_t *ary_ptr)
{
	printf("x:%06d ", ary_ptr[1] << 8 | ary_ptr[0]);
	printf("y:%06d ", ary_ptr[3] << 8 | ary_ptr[2]);
	printf("z:%06d ", ary_ptr[5] << 8 | ary_ptr[4]);
	printf("\n");
}
