/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "gpio_hal.h"
#include "timer_hal.h"

#define BLINK_DELAY	1000 // in millisecond

int main(void)
{
	// RCC clock pointers
	uint32_t *p_RCC_AHB1ENR = (uint32_t*) 0x40023830; // GPIO bus
	uint32_t *p_RCC_APB1ENR = (uint32_t*) 0x40023840; // Timer bus

	// GPIOD register pointer
	GPIOx *p_GPIOD = (GPIOx*) GPIOD_Base_Address;

	// TIMER4 register pointer
	TIMx *p_TIMER4 = (TIMx*) TIM4_Base_Address;

	// RCC clock enable for GPIOD
	*p_RCC_AHB1ENR |= GPIOD_EN;
	// RCC clock enable for Timer 4
	*p_RCC_APB1ENR |= TIMER4_EN;

	// Configure the GPIO in AF mode 2 with high speed output rate.
	p_GPIOD->MODER   |= (GP_OUTPUT_MODE<<Green_Led*BIT_FIELD_2); // Single mode occupies 2 bits
	p_GPIOD->PUPDR   |= (PULL_DWON<<Green_Led*BIT_FIELD_2);

	// Configure the TIMER4
	// If uC is running at 16MHz the counter will increment by one in 16MHz/16000 = 1KHz or 1 count per 1ms
	p_TIMER4->PSC = PRESCALE_16000 - 1;

	// The maximum value till the counter can count and then reset itself.
	p_TIMER4->ARR  = ARR_MAX; // Write register with maximum value for auto-reload

	//Start the timer
	p_TIMER4->CR1   |= CEN_EN;

	uint32_t volatile current_timer_count = 0;
    /* Loop forever */
	while(1){
		p_GPIOD->ODR ^= (LED_ON<<Green_Led);
		current_timer_count = p_TIMER4->CNT;
		while((p_TIMER4->CNT - current_timer_count) < BLINK_DELAY);
	}
}
