/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>

#include "gpio_hal.h"
#include "timer_hal.h"
#include "nvic_hal.h"

#define BLINK_DELAY	1000 // in millisecond

int main(void) {
	// RCC clock pointers
	uint32_t *p_RCC_AHB1ENR = (uint32_t*) 0x40023830; // GPIO bus
	uint32_t *p_RCC_APB1ENR = (uint32_t*) 0x40023840; // Timer bus

	// NVIC pointer
	uint32_t *p_NVIC_ISER = (uint32_t*) NVIC_ISER_Address; // Interrupt Set Enable Register
	//uint32_t *p_NVIC_ICER = (uint32_t*) NVIC_ICER_Address; // Interrupt Clear Enable Register


	// GPIOD register pointer
	GPIOx *p_GPIOD = (GPIOx*) GPIOD_Base_Address;
	GPIOx *p_GPIOA = (GPIOx*) GPIOA_Base_Address;

	// TIMER4 register pointer
	TIMx *p_TIMER4 = (TIMx*) TIM4_Base_Address;

	// RCC clock enable for GPIOD for led output and GPIOA for switch input
	*p_RCC_AHB1ENR |= GPIOD_EN;
	*p_RCC_AHB1ENR |= GPIOA_EN;
	// RCC clock enable for Timer 4
	*p_RCC_APB1ENR |= TIMER4_EN;

	// Configure the led pin as output with high speed output rate.
	p_GPIOD->MODER |= (GP_OUTPUT_MODE << Green_Led * BIT_FIELD_2); // Single mode occupies 2 bits
	p_GPIOD->MODER |= (GP_OUTPUT_MODE << Orange_Led * BIT_FIELD_2); // Single mode occupies 2 bits
	p_GPIOD->PUPDR |= (PULL_DOWN << Green_Led * BIT_FIELD_2);
	p_GPIOD->PUPDR |= (PULL_DOWN << Orange_Led * BIT_FIELD_2);

	// Configure the switch pin as input
	p_GPIOA->MODER |= (GP_INPUT_MODE << User_Button * BIT_FIELD_2); // Single mode occupies 2 bits
	p_GPIOA->PUPDR |= (PULL_DOWN << User_Button * BIT_FIELD_2);

	// Configure the TIMER4
	// If uC is running at 16MHz the counter will increment by one in 16MHz/16000 = 1KHz or 1 count per 1ms
	p_TIMER4->PSC = PRESCALE_16000 - 1;

	// The maximum value till the counter can count and then reset itself.
	p_TIMER4->ARR = BLINK_DELAY; // Write register with delay time, so when the delay complete we can trigger interrupt

	// Enable timer 4 interrupt
	p_TIMER4->DIER |= UIE_EN;

	// Enable the NVIC for timer 4
	*p_NVIC_ISER |= (INTERRPUT_EN<<TIM4_INTERRPUT_POSITION);

	// Turn ON the led
	p_GPIOD->ODR |= (LED_ON << Green_Led);

	//Start the timer
	p_TIMER4->CR1 |= CEN_EN;

	/* Loop forever */
	while (1) {
		// when the button pressed, toggle the state of the orange led
		// Note: Didn't account for the debounce delay
		if(p_GPIOA->IDR & BUTTON_PRESSED){
			p_GPIOD->ODR ^= (LED_ON << Orange_Led);
		}
	}

}

// This is the predefined function
// When the interrupt is triggered the uC will point to a address specific to TIM4 interrupt the function at that location is TIM4_IRQHandler
void TIM4_IRQHandler(void) {
	// In handler mode the system has no reference to the older variables so we need to declare once more

	// Led output toggle
	GPIOx *p_GPIOD = (GPIOx*) GPIOD_Base_Address;
	p_GPIOD->ODR ^= (LED_ON << Green_Led);

	// Reset the interrupt flag in timer register
	TIMx *p_TIMER4 = (TIMx*) TIM4_Base_Address;
	p_TIMER4->SR &= ~UIF_EN;
}
