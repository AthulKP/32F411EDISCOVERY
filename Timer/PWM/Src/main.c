/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>

#include "gpio_hal.h"
#include "timer_hal.h"

#define DUTY_CYCLE	10 // 0-100%

int main(void)
{
	// RCC clock pointers
	uint32_t *p_RCC_AHB1ENR = (uint32_t*) 0x40023830; // GPIO bus
	uint32_t *p_RCC_APB1ENR = (uint32_t*) 0x40023840; // Timer bus

	// GPIOD register pointer
	GPIOx *p_GPIOD = (GPIOx*) GPIOD_Base_Address;

	// TIMER4 register pointer
	TIMx *p_TIMER4 = (TIMx*) TIM4_Base_Address;

	// RCC clock enable for GPIOD
	*p_RCC_AHB1ENR |= GPIOD_EN;
	// RCC clock enable for Timer 4
	*p_RCC_APB1ENR |= TIMER4_EN;

	// Configure the GPIO in AF mode 2 with high speed output rate.
	p_GPIOD->MODER   |= (GP_AF_MODE<<Green_Led*BIT_FIELD_2); // Single mode occupies 2 bits
	p_GPIOD->AFRH    |= (AF_MODE_AF2<<((Green_Led - AF_HIGH_OFFSET)*BIT_FIELD_4)); // Single AF mode occupies 4 bits
	p_GPIOD->OSPEEDR |= (OS_HIGH<<Green_Led);

	// Configure the TIMER4
	// If uC is running at 16MHz the counter will increment by one in 16MHz/1600 = 10KHz or 0-9999 in one second
	p_TIMER4->PSC = PRESCALE_1600 - 1;
	/* 
	The maximum value till the counter and then reset itself.
	100 implies the counter can go from 0 - 100 before reseting back to 0.
	Since the counter update at 10000 per second the ARR gets reseted 10000/100 = 100 times in second or PWMfrq = 100Hz 
	*/
	p_TIMER4->ARR  = ARR_100-1;
	/* 
	The compare value, when the counter reaches say 50% of ARR, we will ask to turn OFF the output. 
	That is the GPIO Pin will be ON for first half and OFF for the second half implies 50% duty cycle
	*/
	p_TIMER4->CCR1 = DUTY_CYCLE;

	p_TIMER4->CCMR1 |= PWM_MODE_1;   	// GPIO pin will we high till the ARR < CCR1 value then switches to low
	p_TIMER4->CCMR1 |= OC1PE_EN;	 	// Enable CCR1 auto-reload
	p_TIMER4->CCER  |= CC1_OUTPUT;	 	// Select the one among the four channel output of TIMER4
	p_TIMER4->CR1   |= ARPE_EN;		 	// Enable ARR auto-reload
	p_TIMER4->EGR   |= UG_REINITIALIZE; // Enable PSC auto-reload

	//Start the timer
	p_TIMER4->CR1   |= CEN_EN;

}
