/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>

#include "timer_hal.h"
#include "gpio_hal.h"
#include "dma_hal.h"

#define MS_COUNT		1450
#define HIGH_DUTY_CYCLE 6
#define LOW_DUTY_CYCLE  3
#define LED_COUNT 	    8
#define BITS_PER_LED	24
#define RESET_BITS      60
#define TOTAL_BITS      (LED_COUNT * BITS_PER_LED)
#define BRIGHTNESS      100

// Function declarations
void WS2812_PrepareData(uint8_t *);
void reduce_led_brigthness(uint8_t *);
void delay_ms(uint32_t);
void individual_LED_RGB(uint8_t *, uint8_t, uint8_t, uint8_t, uint8_t);

// Global variables
uint16_t dma_data[TOTAL_BITS + RESET_BITS];
uint8_t led_data[LED_COUNT * 3];


int main(void)
{
	// RCC clock pointers
	uint32_t *p_RCC_AHB1ENR = (uint32_t *)0x40023830; // GPIO bus
	uint32_t *p_RCC_APB1ENR = (uint32_t *)0x40023840; // Timer bus

	// GPIOD register pointer
	GPIOx *p_GPIOC = (GPIOx *)GPIOC_Base_Address;

	// TIMER3 and TIMER4 register pointer
	TIMx *p_TIMER3 = (TIMx *)TIM3_Base_Address;
	//	TIMx *p_TIMER4 = (TIMx*) TIM4_Base_Address;

	// DMA1 register pointer
	DMAx *p_DMA1 = (DMAx *)DMA1_BASE_ADDRESS;

	// RCC clock enable for GPIOD
	*p_RCC_AHB1ENR |= GPIOC_EN;
	// RCC clock enable for Timer 3 and Timer 4
	*p_RCC_APB1ENR |= TIMER3_EN;
	// RCC clock enable for DMA 1
	*p_RCC_AHB1ENR |= ENABLE_DMA1_CLOCK;

	// Configure the GPIO in AF mode 2 with high speed output rate.
	p_GPIOC->MODER |= (ALTERNATE_FUNCTION_MODE << WS2812B * BIT_FIELD_2); // Single mode occupies 2 bits
	p_GPIOC->AFRL |= (AF_2 << (WS2812B * BIT_FIELD_4));					  // Single AF mode occupies 4 bits
	p_GPIOC->OSPEEDR |= (OS_HIGH << WS2812B);							  // High speed output

	p_TIMER3->PSC = PRESCALE_2;				  // Main clock by half 16MHz to 8MHz
	p_TIMER3->ARR = ARR_10; 				  // Auto reload when counter reaches 10 : Communication frequency = 8MHz / 10 = 800KHz
	p_TIMER3->CCMR1 |= PWM_MODE_1;	  // Till the counter is less than CCR1
	p_TIMER3->CCMR1 |= OC1PE_EN;	  // Enable CCR1 auto-reload
	p_TIMER3->CCER |= CC1_OUTPUT;	  // Select the one among the four channel output of TIMER3
	p_TIMER3->CR1 |= ARPE_EN;		  // Enable ARR auto-reload
	p_TIMER3->EGR |= UG_REINITIALIZE; // Enable PSC auto-reload

	individual_LED_RGB(led_data, 1, 0, 0, 0); // Set array with all led off
	WS2812_PrepareData(led_data);			  // Converting RGB value to PWM value

	// DMA stream configuration
	p_DMA1->S4CR &= ~ENABLE_STREAM; // Disable stream
	while (p_DMA1->S4CR & ENABLE_STREAM)
		;												// Wait for stream disable
	p_DMA1->S4PAR = (uint32_t)&p_TIMER3->CCR1;			// Peripheral address
	p_DMA1->S4M0AR = (uint32_t)&dma_data;				// Variable address
	p_DMA1->S4NDTR = (uint16_t)TOTAL_BITS + RESET_BITS; // Total bits to be transfered before repeating
	p_DMA1->S4CR = STREAM_CHANNEL_5 | HIGH_PRIORITY | HALF_WORD_MEMORY |
				   HALF_WORD_PERIPHERAL | ENABLE_MEMORY_POINTER_INCREMENT |
				   ENABLE_CIRCULAR_MODE | MEMORY_TO_PERIPHERAL_MODE; // DMA configuration

	// Enable DMA for channel 1
	p_TIMER3->DIER |= DMA_CHANNEL_1;

	// Start DMA stream
	p_DMA1->S4CR |= ENABLE_STREAM;

	// Start the timer
	p_TIMER3->CR1 |= CEN_EN;

	while (1)
	{
		for (int i = 150; i > 0; i -= 10)
		{
			for (int j = 1; j <= LED_COUNT; j++)
			{
				individual_LED_RGB(led_data, j, 0, 0, 255);
				WS2812_PrepareData(led_data);
				delay_ms(i);
				individual_LED_RGB(led_data, j, 0, 255, 0);
				WS2812_PrepareData(led_data);
				delay_ms(i);
				individual_LED_RGB(led_data, j, 255, 0, 0);
				WS2812_PrepareData(led_data);
				delay_ms(i);
				individual_LED_RGB(led_data, j, 255, 255, 255);
				WS2812_PrepareData(led_data);
				delay_ms(i);
				individual_LED_RGB(led_data, j, 0, 0, 0);
				WS2812_PrepareData(led_data);
				delay_ms(i);
			}
		}
	}

	individual_LED_RGB(led_data, 1, 0, 0, 0);
	WS2812_PrepareData(led_data);
	delay_ms(50);
	p_TIMER3->CR1 &= ~CEN_EN;
}

// Function to prepare WS2812 PWM data
void WS2812_PrepareData(uint8_t *led_data)
{
	uint32_t index = 0;
	reduce_led_brigthness(led_data);
	for (int i = 0; i < LED_COUNT * 3; i++)
	{
		/* Convert RGB to PWM duty cycle value
		If R = 125 = 0b1111_1111 = {3,6,6,6,6,6,3,6}*/
		for (int bit = 7; bit >= 0; bit--)
		{
			if (led_data[i] & (1 << bit))
			{
				dma_data[index++] = HIGH_DUTY_CYCLE; // "1" duty cycle
			}
			else
			{
				dma_data[index++] = LOW_DUTY_CYCLE; // "0" duty cycle
			}
		}
	}

	// Add reset signal
	for (int i = 0; i < RESET_BITS; i++)
	{
		dma_data[index++] = 0;
	}
}

// Function to reduce brigthness

void reduce_led_brigthness(uint8_t *ptr)
{
	int bit_shift = 0;
	for (int i = 0; i < LED_COUNT * 3; i++)
	{
		bit_shift = (int)((100 - BRIGHTNESS) / 12.5);
		ptr[i] = ptr[i] >> bit_shift;
	}
}

// Function to create led_rgb value array
void individual_LED_RGB(uint8_t *led_data, uint8_t led_number, uint8_t r_data,
						uint8_t g_data, uint8_t b_data)
{
	int i = ((led_number - 1) * 3);
	led_data[i] = g_data;
	led_data[++i] = r_data;
	led_data[++i] = b_data;
}

// Function to create delay in milli-seconds
void delay_ms(uint32_t delay)
{
	for (int i = 0; i < MS_COUNT * delay; i++);
}
